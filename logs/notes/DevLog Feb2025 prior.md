## 12/10/2024

In the main.js the logic can now find properties of a control module class
The properties to look for are hard coded. But for now, it meets the requirement
of extracting information from each FHX object.

Similar exercise can be done from EMC, possibly with another set of hardcoded
property names

More work needs to be done to make these logic reusable across more objects

=> Since the code is able to extract information, the next step is to create tables
in the format of .md .txt .html or any other ideal method of displaying the data
for consumption for the DS creation

## 12/10/2024

#### Tasks:

-Find the rest of the info for DS

## 12/11/2024

Finished a new version of isolateBlock(fhxstring, blockType)
This function can isolate blocks using depth counting
This has the potential of being reused to find the inner blocks for further processings

## 12/12/2024

The code is now able to isolate and extract a given type of blocks (for instance FUNCTION*BLOCK), using \_isolateBlock(fhxstring, blockType)*. This function also works well with inner blocks. In order to properly extract the inner blocks, the input fhx block string has to contain a single fhx block string. Otherwise inner blocks (for instance ATTRIBUTE_INSTANCE) of multiple DeltaV class objects would be returned in a single array.

When extracting inner blocks, the string will retain there original indentation, as they are extracted with String.prototype.substring which includes leading spaces and return characters (\r\n) The functions _blockIndentation(block)_ and _unindentation(blockString, numToUninent)_ works together to identify the indentation level and elimate these leading spaces of each line. And the result is a fhx string containing properly formatted block information of a particular property.

Finally, the function _classProperties(block)_ works on a DeltaV object (root block) and identities the header information (e.g. Description, Type, Scan Rate etc.) of a root block. This function is hard coded with the names of these properties.

TODO: Going forward, we need to be able to extract the desired information from each block, for example the value of a ATTRIBUTE*INSTANCE. And make the isolateBlock function more flexible, able to take an entire FHX and a path to drill down, instead of, currently, manually identify and extract the DV object block of interest before being called again to drill down further.
We also need a way to encapsulate these functions and fhx format data, to make \_classProperties(block)* more flexible

## 12/16/2024

After some renaming, findBlocks(fhxstring, blockType) returns a list of fhx blocks of a particular block Type. identifyBlock(block, name, blocks) isolates the block associated with the name in the input arguments.
TODO: create logic to extract information of each block. 1. From the definition line; 2. From the body enclosed by the bracket; 3. Taking into account of different format of the variables.

## 01/08/2025 (**Copilot autogenerated**)

1. **List of Functions:**

    - `classProperties(block)`: Extracts header properties of a control module class block.
    - `findBlocks(fhxstring, blockType)`: Finds all blocks of a given type in the FHX string.
    - `identifyBlock(blockType, name, blocks)`: Identifies a block with a specific name from a list of blocks.
    - `extractValueFrom(block, keyname)`: Extracts the value of a specific key from a block.

2. **Helper Functions:**

    - `unindentation(blockString, numToUninent)`: Unindents a block string by a specified number of spaces.
    - `blockIndentation(block)`: Finds the number of leading spaces of a block.
    - `tempWrite(input, filename, clear)`: Writes a string to a text file for testing and review.
    - `writeCsv(header, records, filepath, filename)`: Writes a CSV file based on the input header and records.
    - `findParameterList(data, blockType, keys)`: Finds a list of parameters in a block and extracts their values.
    - `fhxReplacer(input, replacer)`: Replaces FHX terms with display terms in a string.
    - `fhxObject(fhxstring, type, name)`: Finds a specific FHX object by type and name.
    - `valuesOfModuleParameters(module_data)`: Extracts default values of module parameters.
    - `valueOf(fhxBlock, key)`: Extracts the value of a specific key from a block.
    - `nameOf(fhxBlock)`: Extracts the name of a block.

3. **Other Edits:**
    - Updated `runner1(fhx_data)` to use the new functions for extracting module parameters and writing them to a CSV file.
    - Added comments and documentation for new functions.

### Notes:

-   The new functions improve the modularity and readability of the code.
-   The `findBlocks` function now supports inner blocks and handles depth changes correctly.
-   The `writeCsv` function simplifies the process of writing CSV files from extracted data.
-   The `fhxReplacer` function can be extended with additional replacer terms as needed.

## 01/10/2025

### Summary of `FileIO.js`:

The `FileIO.js` file contains utility functions for file operations, including:

-   `prepareFilePath(filepath, filename, replace)`: Prepares the directory and file path for writing.
-   `writeTxtFile(data, filepath, filename, replace)`: Writes data to a text file at the specified path.
-   `writeTxtFiles(files, filepath, replace)`: Writes multiple text files to the specified directory.
-   `writeTxtFileConcat(data, filepath, filename, replace)`: Writes a single text file with concatenated data.
-   `writeTxtFileWithPrefix(data, filepath, baseFilename)`: Writes multiple text files with an auto-increment prefix.

### Summary of `obtainModuleParameters`:

The `obtainModuleProperties` function in `main.js`:

-   Extracts the properties of a fhx block header.
-   Creates a CSV file with the extracted properties.

### Tested logic with the `runner` function

-   Finds and processes blocks of type "MODULE_CLASS" where the module is within a specific category (Equipment Module Classes).

## 01/12/2025

### Updates:

-   `fhxProcessor.js` is now dedicated to FHX processing.
-   `DSCreator.js` uses the processor's functions to compile tables necessary for the Design Specification creation project.

### Functionality:

-   `valuesOfModuleParameters(module_data)`: Extracts default values of module parameters from a given module data block. It identifies parameters by checking for attribute blocks with `CATEGORY=COMMON`.

### Purpose of `DesignConsideration.md`:

The `DesignConsideration.md` file is used to explore and record the design roadmap, ideas, and lessons learned throughout the project.

### Future Suggestions:

-   Use software to track issues, ideas, and milestones to make each coding session more effective.
-   Start using unit tests for consistency and to avoid spaghetti code.

## 01/14/2025 (**Copilot autogenerated**)

### Updates:

-   MySQL has been installed locally under `c:\CodeRepo\Coding Env`.
-   MySQL server has been tested and is running successfully.
-   The `mysql2` npm package has been installed in this project and tested to be working.

### Next Steps:

-   Design the database schema for the project.

### Overall Project Structure:

The overall project will consist of the following parts:

-   Parsing tool using EBNF and ANTLR
-   SQL database schema design
-   Query design
-   Application interface

### Note:

-   At this moment, because of the DS Creation effort, the parsing of the FHX with state machine and regex will still be developed and used for immediate outputs.

## 01/14/2025 (**Copilot autogenerated**)

### Updates:

-   Added new functions in `DSCreator.js`: `findAll`, `findAllEMClasses`, `findAllCMClasses`.
-   Moved `processModuleClass` to `DSCreator.js`.
-   `findEMCommands(fhx_data, modulename)` in `main.js` is still a work in progress.

### Current Status of `findEMCommands`:

-   The function can currently find all command definitions for a given Equipment Module (EM) in the provided FHX data.
-   It extracts the command names and their definitions.

-   Look for and parse the associated SFC blocks.

## 01/15/2025

-   renamed fhxObject to findBlockWithName to make it more agnostic

### Updates:

-   Added `compileEMCommands` function in `main.js`.
-   `compileEMCommands` compiles all command definitions for a given Equipment Module (EM) in the provided FHX data.
-   Extracts the command names, their definitions, and writes them to text files.
-   Note: `compileEMCommands` is a work in progress and is to be refactored.

### Updates:

-   Added functionality to extract action values from the `fhxProcessor` and write them to a JSON file.
-   Commented out the previous implementation for extracting action values for `action0` to keep the code clean and maintainable.
-   Ensured the new implementation correctly maps the action values and writes them to `actions.json` in the specified output path.

### Next Steps:

-   Test the new implementation to ensure it correctly writes the expected action values to the JSON file.
-   Remove the commented-out code if it is no longer needed after thorough testing.

## 01/20/2025

The draft version of the FHX parser works. The next steps are to refactor and clean up the code, design an Excel table, and create a proper CSV writer interface.

Create Unit test, and have proper coding habit going forward. (consider hiring a FIVRR helper to clean up and debug code)

Additionally, future projects include converting the state machine parser into an EBNF ANTLR grammar and parsing the entire FHX.

_Note: This devlog is generated by GitHub Copilot._

## 01/21/2025

TODO: need to fix valueOf function to capture the double empty string (two consecutive double quotes)

## 01/23/2025 (**Copilot autogenerated**)

### Updates:

-   Started creating unit tests for the project.
-   Included FHX and TXT files for testing purposes.
-   Configured Git Large File Storage (LFS) to track large files.

### Next Steps:

-   Continue developing unit tests.
-   Refine test strategy
-   Use Copilot to quickly generate tests

## 01/24/2025

Today, we will start refactoring the code with a new UML model. The goal is to improve the structure and maintainability of the codebase. This refactor will involve redesigning the class hierarchy and relationships based on the new UML diagrams.

_Note: This devlog is generated by GitHub Copilot._

## 01/27/2025

Started refactoring FHX Parser code, specifically targeting the generation of design specification required tables. Created a separate folder `DSSpecific` and JavaScript files specifically for module parameters and module properties tables. Commonly used code is put into `common.js`.

_Note: This devlog is generated by GitHub Copilot._

## 01/28/2025

Completed the generation of module property and module parameter tables. Organized DSSpiecific code into it's own folder structures. Plan for the day is to continue the generation of tables for Function BLocks, Composites, and Alarms, associated with \_C_M_AGIT_M

EOD: Completed the generation of Function Block, LinkedComposite, Embedded Composite, Alarms and History Collection tables.

## 01/29/2025

Plan for the day: examine if there are other tables that need working on - done with PID and USM
refactor the code to take module names as inputs - done
Table generation for all modules - done
Bulk edit and create the table for instance configurable parameters - done

EOD update:
All control module class tables are successfully generated. Further test required
Also, wrote code to handle empty string values (two back to back double quotes "" of a string parameter)
code to handle permitted mode.
Some of these handlers are hardcoded for the moment.

Next up, use the same logic to parse Equipment module tables.
current v1 version of dscreator.sfcToCsv() and fhxProcessor.processSFC functions still work

## 01/30/2025

TODO: Included code to create EM child devices table and commands table

Need to loop and create tables for the nested EM embedded composites
And do the same with Command SFC's, which are found as part of embedded Composites

## 02/03/2025

**Created plans and sprint schedules. Targeting milestones, complete package of DS creation code by March 14.**
Today: Examine tables for nested blocks

EOD: New code to automatically generate test run folders. Created its associated unit tests.

## 02/04/2025

Study EM, and architect code to digest nested code.
EOD: structured code to encapsulate FHX component and Function Block; Also started the HandleComposites.js file, intended to identify and handle various composites and nested composites.

## 02/06/2025

The effort of reconstitution of the fhx with methods in the Components and their associated unit tests still need bugfixes
The reconsitution feature is less relevant to the DS project at this point.

Nested block design:
process a module
get a list of function blocks
identify any fb to be an embedded block,
find its definition (if it is an embedded composite, it has an definintion),
Process the definition with the same function that processed the module.

EOD: Very little progress has been made. As before, I'm running in circles when it comes to design the data model. The goal is to find a function block and find its definition, and process that function block definition. But I can't seem to be able to come up with a good solution to associate the function block and its definition with the original object, a module for instance.
Also I spent way too much time to figure out how to test pieces of code, which became a cumbersome and pointless exercis.

Currently I'm using the SimpleModuleClass class to capture the bare minimun info of a module class block (attribute, attribute instances, and function blocks) There are methods to identify the function block's name and definition and another method to find the function block definition given an overall fhx as input.

In order to process nested blocks, I can either have a global string object storing the overall fhx and be used by all the loop and nested iterations. Or I can somehow store the necessary fhx info in the objects. The second method requires each object being aware of its associated definition objects. This might be a better approach but requiring the digestion of the entire overall fhx in order to look up all fhx blocks.

The first approach might be better, even though more data needs to be stored and processed.

1. Identify and create a block object (Module Class), and process the block, by extracting module parameter and other tables \*
2. Identify its function blocks, and ones that have custom definitions (Composites).
3. Identify which ones are Embedded blocks
4. Use the block processing code to process embedded blocks. Some tables only apply for module class, not embedded blocks, same goes with EM. Therefore the processing should identify what tables to create based on the type of block passed to its arguments.

-   The processing of a block, i.e. creating parameter and other tables should be handled separately. So it can be reused by the nested blocks.
-   Should identify the type of the block in order to return the correct tables.

## 02/07/2025

Pivotted the design to start fhx processing version 3. See the v3 folder for design philosophy.
Created mock processing functions, console logs. The processing function down the nested tree needs to be optimized, based on where and how to call these functions in the different objects.
Tests need to be created so that future modification of the FhxProcessor and other components' effect on existing code can be closely monitored.

## 02/10/2025

EOD:
Created ways to digest fhx, findNextComponent, and adding the components found in the object manager. Created tests to test relevant code.
Next step, making sure all the relevant objects are consumed and included in the object manager.
Generalize the previous processing function to create data ables.

## 02/13/2025

EOD:
~~Refactored ModuleClass component to call for its own table creation.~~
Created DSProcessor.js to handle DS specific functions, which includes aseembling necessary information from the components and create table from them.
Each create table class is targetted for a single table in the design specification, so additional tables can be added in the future should new tables are needed. DeignSpecTables master class simply need to call the additional tables.
Refactored ObjectCreator to ComponentCreator, which handles switching the type of component to create the correct one. _This code might be redundant, as DSProcessor also does the check of whether the compone is an instance of a specific component class._ the type information already exist with in the component (a parent class field)
The Component Proessor class (ComponentProcessor.js) is not being used
This is the end of sprint 02/03-02/13. I should do sprint retrospective

## 02/17/2025

Sprint #2 Start:

-   Examine the DS table coverage
-   Examine test coverage
-   Major refactor for agnosticity, and interface design

## 02/19/2025

In main.js, working on functions to go through each block to identify all unique parameter keys possible in that type of block.
Currently working on coding a exhaustive list of all parameters in each elements. All these possible info should be stored in their respective components.
For example, in the ATTRIBUTE component, all possible parameters: TYPE, READONLY, EDITABLE, RECTANGLE, HELP_ID, CATEGORY, would all be stored in each attribute object. The exercise to find all unique parameters will ensure the full coverage of all elements

I was able to write functions to give an exhaustive list which contains all the elements of ATTRIBUTE, FUNCTION_BLOCK, and ATTRIBUTE_INSTANCEs. However the value block and historization block in the attribute instances need to be handled differently. Previously this was quite a manual proess. So when it comes time to write the class for Enumeration (Namedset) Components, I decided to rewrite a more generic function to find unique elements. Using the input from FunctionBlocks.txt which is a manual compilation of 4 different function block blocks. I wrote unique.test.js to help rapid test as I'm coding the unique() function. The expected result of the output given this txt file should be quite straightforwardly a json object with nested keys representing the content of the txt file. -- WIP use "npx mocha unique.test.js" to perform the test
